# 死循环问题修复说明

## 🐛 问题分析

### 问题现象

控制台不断打印：

```
Already fetching balance, skipping...
Already fetching balance, skipping...
Already fetching balance, skipping...
...无限循环
```

### 根本原因

**依赖链式反应导致的无限循环**：

```
1. useTokenContract 每次创建新的 Contract 实例
   ↓
2. tokenContract 引用改变
   ↓
3. fetchBalance 的 useCallback 依赖 tokenContract → 重新创建
   ↓
4. fetchBalance 改变
   ↓
5. useEffect 依赖 fetchBalance → 触发
   ↓
6. 调用 fetchBalance
   ↓
7. 状态可能更新 → 重新渲染
   ↓
8. 回到步骤 1 → ♻️ 死循环！
```

## 🔧 修复方案

### 修复 1: useTokenContract 添加缓存机制

**问题**: 每次渲染都创建新的 Contract 实例

**解决**: 使用 `useRef` 缓存合约实例

```typescript
// web/src/hooks/useContract.ts

export function useTokenContract(tokenAddress: string | null) {
  const provider = useEthersProvider()
  const signer = useEthersSigner()
  const contractRef = useRef<any>(null)
  const lastTokenRef = useRef<string | null>(null)
  const lastSignerRef = useRef<any>(null)

  return useMemo(() => {
    if (!tokenAddress) return null

    // ✅ 如果 token 地址和 signer 都没变，返回缓存的合约
    if (contractRef.current && lastTokenRef.current === tokenAddress && lastSignerRef.current === signer) {
      return contractRef.current // 返回缓存，不创建新实例
    }

    // 只有在真正需要时才创建新实例
    if (signer) {
      const contract = new Contract(tokenAddress, ERC20_ABI, signer)
      contractRef.current = contract
      lastTokenRef.current = tokenAddress
      lastSignerRef.current = signer
      return contract
    }

    if (provider) {
      const contract = new Contract(tokenAddress, ERC20_ABI, provider)
      contractRef.current = contract
      lastTokenRef.current = tokenAddress
      lastSignerRef.current = null
      return contract
    }

    return null
  }, [tokenAddress, provider, signer])
}
```

### 修复 2: useTokenBalance 使用 useRef 避免依赖对象

**问题**: useEffect 依赖 `fetchBalance` 和 `tokenContract`，导致循环触发

**解决**: 使用 `useRef` 保存 `tokenContract`，`useCallback` 只依赖基本类型

```typescript
// web/src/hooks/useTokenBalance.ts

// 使用 useRef 保存最新的 tokenContract
const tokenContractRef = useRef(tokenContract)
tokenContractRef.current = tokenContract

// ✅ fetchBalance 只依赖基本类型，不依赖对象
const fetchBalance = useCallback(async () => {
  if (!isConnected || !address || !tokenAddress) {
    setBalance("0")
    return
  }

  // 从 ref 中获取最新的 contract，避免作为依赖
  const contract = tokenContractRef.current
  if (!contract) {
    return
  }

  // ... 执行 balanceOf ...
}, [isConnected, address, tokenAddress]) // ✅ 只依赖基本类型
```

### 修复 3: Swap.tsx 和 Liquidity.tsx 避免依赖 refetch 函数

**问题**: 组件的 `useEffect` 依赖 `refetchBalance` 函数，导致循环触发

**解决**: 使用 `useRef` 保存 refetch 函数引用

```typescript
// web/src/components/Swap.tsx

// 使用 useRef 保存 refetch 函数，避免依赖问题
const refetchBalanceInRef = useRef(refetchBalanceIn)
refetchBalanceInRef.current = refetchBalanceIn

// ✅ 当代币切换时强制刷新余额（不依赖 refetch 函数）
useEffect(() => {
  // 使用 ref 访问最新的 refetch 函数
  refetchBalanceInRef.current()
  refetchBalanceOutRef.current()
}, [tokenIn.address, tokenOut.address]) // ✅ 只依赖地址，不依赖函数
```

### 修复 4: 添加详细调试日志

```typescript
// 跟踪渲染次数
const renderCountRef = useRef(0)
renderCountRef.current += 1

useEffect(() => {
  console.log(`📊 [useTokenBalance] Render #${renderCountRef.current}`, {
    tokenAddress,
    address: address?.slice(0, 10),
    isConnected,
    hasContract: !!tokenContract
  })
})

// Effect 触发日志
useEffect(() => {
  console.log("🔄 [useTokenBalance] Fetching balance...")
  fetchBalance()
}, [address, isConnected, tokenAddress])
```

## 📊 修复前后对比

### 修复前（死循环）

```
[useTokenBalance] Render #1
📝 Created new token contract with signer for 0x4798...
[useTokenBalance] Effect triggered
🔄 Fetching balance...
[useTokenBalance] Render #2
📝 Created new token contract with signer for 0x4798... ← 又创建了！
[useTokenBalance] Effect triggered ← 又触发了！
🔄 Fetching balance...
Already fetching balance, skipping...
[useTokenBalance] Render #3
📝 Created new token contract with signer for 0x4798... ← 继续创建！
[useTokenBalance] Effect triggered ← 继续触发！
Already fetching balance, skipping... ← 死循环！
...无限循环
```

### 修复后（正常）

```
[useTokenBalance] Render #1
📝 Created new token contract with signer for 0x4798...
[useTokenBalance] Effect triggered
🔄 Fetching balance...
✅ Balance fetched for 0x4798...: 1250.50

[useTokenBalance] Render #2
✅ 使用缓存的合约，不再创建新实例
✅ Effect 不再触发，因为依赖没变

✅ 只执行一次，不会循环！
```

## 🎯 关键要点

### 1. React Hooks 依赖规则

- `useMemo` / `useCallback` / `useEffect` 的依赖数组必须包含所有使用的外部变量
- 但是，过多的依赖会导致循环触发
- 解决方案：
  - ✅ 缓存不变的对象（useRef）
  - ✅ 只依赖真正需要响应的值
  - ✅ 在函数内部使用闭包访问最新值

### 2. 对象引用稳定性

```typescript
// ❌ 每次都是新对象，引用不同
const contract = new Contract(address, abi, signer)

// ✅ 使用 useRef 缓存，引用稳定
const contractRef = useRef(null)
if (!contractRef.current) {
  contractRef.current = new Contract(address, abi, signer)
}
```

### 3. 调试技巧

```typescript
// 添加渲染计数器
const renderCount = useRef(0)
renderCount.current += 1
console.log("Render #", renderCount.current)

// 跟踪依赖变化
useEffect(() => {
  console.log("Dependency changed:", { dep1, dep2, dep3 })
}, [dep1, dep2, dep3])
```

## 🔍 如何验证修复

打开浏览器控制台，你应该看到：

### 正常情况：

```
📊 [useTokenBalance] Render #1 { tokenAddress: "0x4798...", ... }
📝 Created new token contract with signer for 0x4798...
🔄 [useTokenBalance] Fetching balance...
✅ Balance fetched for 0x4798...: 1250.50

✅ 只有初始化时执行一次
✅ 切换代币时才会重新执行
```

### 异常情况（需要检查）：

```
❌ Render 计数器不断增加 (#1, #2, #3, ...)
❌ 不断创建新合约 (Created new token contract...)
❌ 不断打印 "Already fetching balance, skipping..."
```

## ✅ 测试清单

- [ ] 页面加载后，余额只获取一次
- [ ] 控制台没有 "Already fetching balance, skipping..." 循环日志
- [ ] 切换代币时，会重新获取余额（这是正常的）
- [ ] 点击刷新按钮，手动刷新余额正常
- [ ] Render 计数器不会无限增长

## 📝 后续优化

如果调试日志太多，可以在稳定后移除：

```typescript
// 移除这些调试日志：
useEffect(() => {
  console.log(`[useTokenBalance] Render #${renderCountRef.current}`, ...);
});

console.log('📊 [useTokenBalance] Effect triggered', ...);
console.log('🔄 [useTokenBalance] Fetching balance...');
```

保留这些有用的日志：

```typescript
console.log(`✅ Balance fetched for ${tokenAddress}: ${balance}`)
console.log("❌ Error fetching balance:", error)
console.log("📝 Created new token contract with signer for ...")
```

---

**修复完成时间**: 2025-10-23  
**问题类型**: React Hooks 依赖循环  
**修复难度**: ⭐⭐⭐⭐ (中高)
