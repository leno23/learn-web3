# 死循环问题完全修复方案

## 🎯 问题根源

### 完整的依赖循环链条

```
1. useTokenContract 创建新的 Contract 实例
   ↓
2. tokenContract 引用改变
   ↓
3. fetchBalance (useCallback) 依赖 tokenContract → 重新创建
   ↓
4. refetch 函数引用改变
   ↓
5. Swap.tsx 的 useEffect 依赖 refetch → 触发
   ↓
6. 调用 refetch() → useTokenBalance 内部 useEffect 也触发
   ↓
7. 状态更新 → 重新渲染
   ↓
8. 回到步骤 1 → ♻️ 死循环！
```

## 🔧 完整修复方案（三层修复）

### 第一层：useTokenContract 缓存机制

**位置**: `web/src/hooks/useContract.ts`

**问题**: 每次渲染都创建新的 Contract 实例

**修复**: 使用 `useRef` 缓存合约实例

```typescript
export function useTokenContract(tokenAddress: string | null) {
  const provider = useEthersProvider()
  const signer = useEthersSigner()
  const contractRef = useRef<any>(null)
  const lastTokenRef = useRef<string | null>(null)
  const lastSignerRef = useRef<any>(null)

  return useMemo(() => {
    if (!tokenAddress) return null

    // ✅ 如果 token 地址和 signer 都没变，返回缓存的合约
    if (contractRef.current && lastTokenRef.current === tokenAddress && lastSignerRef.current === signer) {
      return contractRef.current // 返回缓存，不创建新实例
    }

    // 只有真正需要时才创建新实例
    if (signer) {
      const contract = new Contract(tokenAddress, ERC20_ABI, signer)
      contractRef.current = contract
      lastTokenRef.current = tokenAddress
      lastSignerRef.current = signer
      return contract
    }

    // ... 省略 provider 分支
  }, [tokenAddress, provider, signer])
}
```

**效果**: 减少了不必要的 Contract 实例创建，但还不够

---

### 第二层：useTokenBalance 使用 useRef

**位置**: `web/src/hooks/useTokenBalance.ts`

**问题**: `fetchBalance` 依赖 `tokenContract` 对象，即使缓存了也会因为引用变化重新创建

**修复**: 使用 `useRef` 保存 `tokenContract`，`useCallback` 只依赖基本类型

```typescript
export function useTokenBalance(tokenAddress: string | null) {
  const { address, isConnected } = useAccount()
  const tokenContract = useTokenContract(tokenAddress)

  // ✅ 使用 useRef 保存最新的 tokenContract，避免依赖问题
  const tokenContractRef = useRef(tokenContract)
  tokenContractRef.current = tokenContract

  // ✅ fetchBalance 只依赖基本类型，不依赖对象引用
  const fetchBalance = useCallback(async () => {
    if (!isConnected || !address || !tokenAddress) {
      setBalance("0")
      return
    }

    // 从 ref 中获取最新的 contract，避免作为依赖
    const contract = tokenContractRef.current
    if (!contract) {
      return
    }

    // 执行 balanceOf 调用
    const bal = await contract.balanceOf(address)
    setBalance(formatUnits(bal, 18))
  }, [isConnected, address, tokenAddress]) // ✅ 只依赖基本类型（string, boolean）

  return { balance, loading, refetch: fetchBalance }
}
```

**关键点**:

- `fetchBalance` 现在只依赖 `[isConnected, address, tokenAddress]`
- 这些都是基本类型（string, boolean），引用稳定
- `tokenContract` 通过 `useRef` 访问，不作为依赖

**效果**: `fetchBalance` 引用稳定，但 Swap.tsx 中的问题还在

---

### 第三层：Swap.tsx 和 Liquidity.tsx 避免依赖 refetch

**位置**: `web/src/components/Swap.tsx`, `web/src/components/Liquidity.tsx`

**问题**: 组件的 `useEffect` 依赖 `refetchBalance` 函数

```typescript
// ❌ 之前的错误代码
useEffect(() => {
  refetchBalanceIn()
  refetchBalanceOut()
}, [tokenIn.address, tokenOut.address, refetchBalanceIn, refetchBalanceOut])
//                                      ↑ 这些函数依赖导致循环
```

即使 `fetchBalance` 只依赖基本类型，当 `tokenIn.address` 变化时：

1. `useTokenBalance(tokenIn.address)` 重新调用
2. `fetchBalance` 重新创建（因为 `tokenAddress` 依赖变了）
3. `refetchBalanceIn` 引用改变
4. Swap.tsx 的 `useEffect` 触发
5. 调用 `refetchBalanceIn()`
6. 内部 `useEffect` 也触发（因为 `fetchBalance` 在依赖数组中）
7. 可能导致多次调用

**修复**: 使用 `useRef` 保存 refetch 函数引用

```typescript
// ✅ Swap.tsx 修复后的代码
export default function Swap() {
  const { balance: balanceIn, refetch: refetchBalanceIn } = useTokenBalance(tokenIn.address)
  const { balance: balanceOut, refetch: refetchBalanceOut } = useTokenBalance(tokenOut.address)

  // 使用 useRef 保存 refetch 函数，避免依赖问题
  const refetchBalanceInRef = useRef(refetchBalanceIn)
  const refetchBalanceOutRef = useRef(refetchBalanceOut)

  // 更新 ref（每次渲染都更新，保证是最新的）
  refetchBalanceInRef.current = refetchBalanceIn
  refetchBalanceOutRef.current = refetchBalanceOut

  // ✅ 当代币切换时强制刷新余额（不依赖 refetch 函数）
  useEffect(() => {
    // 使用 ref 访问最新的 refetch 函数
    refetchBalanceInRef.current()
    refetchBalanceOutRef.current()
  }, [tokenIn.address, tokenOut.address]) // ✅ 只依赖地址，不依赖函数
}
```

**关键点**:

- `useEffect` 只依赖 `[tokenIn.address, tokenOut.address]`
- 这些是 string 类型，引用稳定（除非真的切换代币）
- `refetch` 函数通过 `useRef` 访问，不作为依赖

**效果**: 彻底断开循环链条！

---

## 📊 修复前后对比

### 修复前（死循环）

```
[Swap] Render #1
📊 [useTokenBalance] Render #1
📝 Created new token contract with signer for 0x4798...
🔄 [useTokenBalance] Effect triggered - Fetching balance...

[Swap] Render #2 ← 开始循环
📊 [useTokenBalance] Render #2
📝 Created new token contract with signer for 0x4798... ← 又创建了
🔄 [useTokenBalance] Effect triggered - Fetching balance...
⚠️ Already fetching balance, skipping...

[Swap] Render #3 ← 继续循环
📊 [useTokenBalance] Render #3
📝 Created new token contract with signer for 0x4798... ← 继续创建
⚠️ Already fetching balance, skipping... ← 不断跳过

... 无限循环 ...
```

### 修复后（正常）

```
[Swap] Render #1
📊 [useTokenBalance] Render #1 { tokenAddress: "0x4798...", ... }
📝 Created new token contract with signer for 0x4798...
🔄 [useTokenBalance] Effect triggered - Fetching balance...
✅ Balance fetched for 0x4798...: 1250.50

[Swap] Render #2
📊 [useTokenBalance] Render #2
✅ 使用缓存的合约，不再创建新实例
✅ fetchBalance 引用稳定，不重新创建
✅ Effect 不触发（依赖没变）

✅ 只执行一次，不会循环！
```

---

## 🎯 关键技术要点

### 1. React Hooks 依赖最佳实践

```typescript
// ❌ 错误：依赖对象引用
useCallback(() => {
  contract.doSomething()
}, [contract]) // 对象引用可能每次都变

// ✅ 正确：只依赖基本类型
const contractRef = useRef(contract)
contractRef.current = contract

useCallback(() => {
  contractRef.current.doSomething()
}, [id, name]) // 只依赖 string 等基本类型
```

### 2. useRef 的两种用途

**用途 1: 保存可变值**

```typescript
const countRef = useRef(0)
countRef.current += 1 // 修改不会触发重新渲染
```

**用途 2: 保存最新的函数/对象引用**

```typescript
const callbackRef = useRef(callback)
callbackRef.current = callback // 每次渲染都更新

// 在 effect 中使用
useEffect(() => {
  callbackRef.current() // 总是调用最新的
}, []) // 依赖数组为空，不会重复触发
```

### 3. 对象引用稳定性原则

```typescript
// 基本类型：值相同，引用就相同
const a = "hello"
const b = "hello"
console.log(a === b) // true

// 对象类型：即使内容相同，引用也不同
const obj1 = { name: "Alice" }
const obj2 = { name: "Alice" }
console.log(obj1 === obj2) // false

// 所以在 React 依赖数组中：
useEffect(() => {
  // ...
}, [name]) // ✅ string 类型，引用稳定

useEffect(() => {
  // ...
}, [contract]) // ❌ 对象类型，引用可能每次都变
```

---

## ✅ 验证修复

### 正常情况（应该看到）

```
✅ 页面加载后，余额只获取一次
✅ Render 计数器稳定（#1, #2, 然后停止）
✅ 只看到一次 "Created new token contract"
✅ 只看到一次 "Balance fetched"
✅ 切换代币时，会重新获取一次（正常）
```

### 异常情况（如果看到，说明还有问题）

```
❌ Render 计数器不断增加 (#1, #2, #3, #4, ...)
❌ 不断创建新合约
❌ 不断打印 "Already fetching balance, skipping..."
❌ CPU 使用率很高
```

---

## 🧪 测试步骤

1. **刷新页面**（Ctrl + Shift + R）
2. **打开控制台**（F12）
3. **连接钱包**
4. **观察日志**:
   - 应该只看到初始化日志
   - Render 计数器应该稳定
5. **切换代币**:
   - 会看到 "Token changed, refreshing balances..."
   - 会重新获取一次余额（这是正常的）
   - 然后又稳定下来
6. **点击刷新按钮**:
   - 会手动刷新一次
   - 然后又稳定下来

---

## 🎓 总结

### 问题本质

React Hooks 的依赖循环问题，本质上是：

- **对象引用不稳定** + **过度依赖对象** = **无限循环**

### 解决方案

1. **缓存对象**：使用 `useRef` 或 `useMemo` 稳定对象引用
2. **避免依赖对象**：只依赖基本类型（string, number, boolean）
3. **使用 useRef 访问最新值**：通过 ref 间接访问对象，而不是直接依赖

### 适用场景

这个模式适用于所有需要在 Hook 中使用外部对象的场景：

- Contract 实例
- Callback 函数
- 复杂对象
- 第三方库实例

---

**修复完成**: 2025-10-23  
**问题类型**: React Hooks 依赖循环（三层嵌套）  
**修复难度**: ⭐⭐⭐⭐⭐ (高)  
**学习价值**: ⭐⭐⭐⭐⭐ (非常高)
