# Swap 报价功能修复说明

## 🐛 问题描述

### 问题 1: Contract Runner 错误

在 Swap 页面输入 TokenA 数量后，获取报价时出现错误：

```
Error getting quote: Error: contract runner does not support sending transactions
(operation="sendTransaction", code=UNSUPPORTED_OPERATION, version=6.15.0)
```

### 问题 2: SPL (Sqrt Price Limit) 错误

修复问题 1 后，又出现新的错误：

```
Error: execution reverted: "SPL"
```

## 🔍 问题原因

### 问题 1 原因

在 **ethers.js v6** 中，当合约实例使用 `signer` 创建时，直接调用合约方法会被识别为**发送交易**，即使该方法是 `view` 或 `pure` 函数（只读函数）。

原代码：

```typescript
// ❌ 错误：会尝试发送交易
const quote = await router.quoteExactInput({
  tokenIn: tokenIn.address,
  tokenOut: tokenOut.address,
  indexPath: [selectedFeeTier?.index ?? 1],
  amountIn: amountInWei,
  sqrtPriceLimitX96: 0
})
```

### 问题 2 原因

在 Pool 合约中，有一个价格限制检查：

```solidity
require(
    zeroForOne
        ? sqrtPriceLimitX96 < sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_PRICE
        : sqrtPriceLimitX96 > sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_PRICE,
    "SPL"  // Sqrt Price Limit error
);
```

当 `sqrtPriceLimitX96 = 0` 时：

- **如果 zeroForOne 为 true**: 需要 `0 > MIN_SQRT_PRICE`，永远为 false
- **如果 zeroForOne 为 false**: 需要 `0 < MAX_SQRT_PRICE`，虽然为 true，但 `0 > sqrtPriceX96` 为 false

所以设置为 `0` 时会导致价格检查失败！

## ✅ 解决方案

### 解决方案 1: 使用 staticCall

使用 `.staticCall` 方法明确指定这是一个**只读调用**（不修改区块链状态）：

```typescript
// ✅ 使用 staticCall 进行只读调用
const quote = await router.quoteExactInput.staticCall({
  ...params
})
```

### 解决方案 2: 设置正确的价格限制

根据代币地址大小关系计算 `zeroForOne`，然后设置正确的 `sqrtPriceLimitX96`：

```typescript
// 计算 zeroForOne (token 地址比较大小)
const zeroForOne = tokenIn.address.toLowerCase() < tokenOut.address.toLowerCase()

// 设置价格限制：不限制价格时使用极限值
// MIN_SQRT_PRICE = 4295128739
// MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342
const sqrtPriceLimitX96 = zeroForOne
  ? BigInt("4295128740") // MIN_SQRT_PRICE + 1
  : BigInt("1461446703485210103287273052203988822378723970341") // MAX_SQRT_PRICE - 1

const quote = await router.quoteExactInput.staticCall({
  tokenIn: tokenIn.address,
  tokenOut: tokenOut.address,
  indexPath: [selectedFeeTier?.index ?? 1],
  amountIn: amountInWei,
  sqrtPriceLimitX96: sqrtPriceLimitX96 // ✅ 使用正确的价格限制
})
```

## 📚 技术背景

### ethers.js v6 的调用方式

在 ethers.js v6 中，合约方法调用有三种方式：

1. **普通调用**（默认行为）

   ```typescript
   await contract.someMethod(params)
   ```

   - 如果合约有 `signer`：发送交易（修改状态）
   - 如果合约只有 `provider`：只读调用

2. **staticCall**（强制只读）

   ```typescript
   await contract.someMethod.staticCall(params)
   ```

   - 总是进行只读调用，不修改状态
   - 适用于 `view` 和 `pure` 函数
   - **推荐用于获取数据的场景**

3. **estimateGas**（估算 gas）
   ```typescript
   await contract.someMethod.estimateGas(params)
   ```
   - 估算执行交易所需的 gas
   - 不会实际发送交易

### 为什么需要 staticCall？

在 Swap 组件中：

- `useSwapRouter()` 返回的合约实例优先使用 `signer`（用于后续的实际交换交易）
- `quoteExactInput` 是一个 `view` 函数，只用于获取报价，不应该发送交易
- 如果不使用 `.staticCall`，ethers 会尝试发送交易，导致错误

## 📝 修改文件

- ✅ `web/src/components/Swap.tsx` - 第 91-145 行（getQuote 函数）
- ✅ `web/src/components/Swap.tsx` - 第 187-255 行（handleSwap 函数）

### 修改内容

#### 1. getQuote 函数

```diff
+ // 计算 zeroForOne (token 地址比较大小)
+ const zeroForOne = tokenIn.address.toLowerCase() < tokenOut.address.toLowerCase();
+
+ // 设置价格限制
+ const sqrtPriceLimitX96 = zeroForOne
+   ? BigInt('4295128740')  // MIN_SQRT_PRICE + 1
+   : BigInt('1461446703485210103287273052203988822378723970341');  // MAX_SQRT_PRICE - 1

- const quote = await router.quoteExactInput({
+ const quote = await router.quoteExactInput.staticCall({
    tokenIn: tokenIn.address,
    tokenOut: tokenOut.address,
    indexPath: [selectedFeeTier?.index ?? 1],
    amountIn: amountInWei,
-   sqrtPriceLimitX96: 0,
+   sqrtPriceLimitX96: sqrtPriceLimitX96,
  });
```

#### 2. handleSwap 函数

```diff
+ // 计算 zeroForOne
+ const zeroForOne = tokenIn.address.toLowerCase() < tokenOut.address.toLowerCase();
+
+ // 设置价格限制
+ const sqrtPriceLimitX96 = zeroForOne
+   ? BigInt('4295128740')
+   : BigInt('1461446703485210103287273052203988822378723970341');

  const tx = await swapRouter.exactInput({
    tokenIn: tokenIn.address,
    tokenOut: tokenOut.address,
    indexPath: [selectedFeeTier?.index ?? 1],
    recipient: address,
    deadline: deadline,
    amountIn: amountInWei,
    amountOutMinimum: amountOutMin,
-   sqrtPriceLimitX96: 0,
+   sqrtPriceLimitX96: sqrtPriceLimitX96,
  });
```

## 🎯 修复效果

- ✅ 输入金额后可以正常获取报价
- ✅ 不会尝试发送交易（使用 staticCall）
- ✅ 只读调用，不消耗 gas
- ✅ 价格限制检查通过（使用正确的 sqrtPriceLimitX96）
- ✅ 响应速度快
- ✅ 实际 Swap 交易也能正常执行

## 🔄 其他可能需要 staticCall 的场景

在项目中，以下场景也应该使用 `.staticCall`：

1. **获取池子信息**

   ```typescript
   const poolInfo = await poolManager.getPool.staticCall(token0, token1, fee)
   ```

2. **计算流动性**

   ```typescript
   const liquidity = await positionManager.calculateLiquidity.staticCall(params)
   ```

3. **查询余额**（如果使用 signer 的合约实例）
   ```typescript
   const balance = await tokenContract.balanceOf.staticCall(address)
   ```

## 💡 最佳实践

### 方案 1: 使用 staticCall（推荐）

```typescript
// 对于只读操作，明确使用 staticCall
const result = await contract.viewFunction.staticCall(params)
```

**优点：**

- 明确语义，代码可读性好
- 不会意外发送交易
- 可以使用同一个合约实例

### 方案 2: 分离只读和写入合约

```typescript
// 创建两个合约实例
const readOnlyContract = new Contract(address, abi, provider) // 只读
const writableContract = new Contract(address, abi, signer) // 写入

// 只读操作
const result = await readOnlyContract.viewFunction(params)

// 写入操作
const tx = await writableContract.writeFunction(params)
```

**优点：**

- 分离关注点
- 防止误操作

**缺点：**

- 需要维护两个实例
- 占用更多内存

## 🚀 验证

运行项目并测试：

```bash
cd web
pnpm dev
```

测试步骤：

1. 打开 Swap 页面
2. 输入 TokenA 数量（例如：1）
3. ✅ 应该自动显示 TokenB 的预估数量
4. ✅ 不应该有任何错误

## 📖 参考资料

- [ethers.js v6 文档 - Contract Interaction](https://docs.ethers.org/v6/api/contract/)
- [ethers.js v6 迁移指南](https://docs.ethers.org/v6/migrating/)

## 🔑 关键技术点

### sqrtPriceLimitX96 参数说明

`sqrtPriceLimitX96` 是 Uniswap V3 用于限制交易价格滑点的参数：

- **作用**: 限制交易执行的最终价格
- **格式**: Q64.96 格式的定点数（96 位小数精度）
- **范围**:
  - 最小值: `MIN_SQRT_PRICE = 4295128739`
  - 最大值: `MAX_SQRT_PRICE = 1461446703485210103287273052203988822378723970342`

### 为什么不能设置为 0？

在 Pool 合约中，价格限制检查会验证：

- 从 token0 到 token1 (zeroForOne=true): `MIN_SQRT_PRICE < sqrtPriceLimitX96 < currentPrice`
- 从 token1 到 token0 (zeroForOne=false): `currentPrice < sqrtPriceLimitX96 < MAX_SQRT_PRICE`

设置为 0 时，这些条件都无法满足，导致 "SPL" 错误。

### 为什么要使用 BigInt？

`sqrtPriceLimitX96` 是 `uint160` 类型，这是一个非常大的整数。JavaScript 的 `Number` 类型无法精确表示这么大的数字，必须使用 `BigInt` 类型：

```typescript
// ❌ 错误：字符串会导致类型错误
const sqrtPriceLimitX96 = "4295128740"

// ✅ 正确：使用 BigInt
const sqrtPriceLimitX96 = BigInt("4295128740")
```

### 正确的做法

当不想限制价格时（接受任何滑点），应该使用：

- zeroForOne=true: 使用 `MIN_SQRT_PRICE + 1`
- zeroForOne=false: 使用 `MAX_SQRT_PRICE - 1`

这样可以通过价格检查，同时实际上不会限制交易。

## ✨ 总结

此次修复解决了 Swap 报价功能的两个核心问题：

1. **ethers.js v6 调用方式问题**

   - ✅ 使用 `.staticCall` 明确只读调用
   - ✅ 避免意外发送交易

2. **价格限制参数问题**
   - ✅ 正确计算 zeroForOne
   - ✅ 设置合法的 sqrtPriceLimitX96 值
   - ✅ 通过合约的价格检查

最终效果：

- ✅ 用户体验流畅，自动获取报价
- ✅ 代码更加健壮和规范
- ✅ 符合 ethers.js v6 和 Uniswap V3 最佳实践
- ✅ 实际交易也能正常执行
