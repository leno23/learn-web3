# 自动报价功能修复说明

## 🐛 问题描述

**现象**: Swap 页面输入 TokenA 的数量后，不会自动计算出 TokenB 的数量

## 🔍 问题根源

### 原代码的问题

```typescript
// ❌ 问题代码
const getQuote = async (amount: string) => {
  // ... 报价逻辑
}

useEffect(() => {
  const timer = setTimeout(() => {
    if (amountIn) {
      getQuote(amountIn)
    }
  }, 500)
  return () => clearTimeout(timer)
}, [amountIn, tokenIn, tokenOut, selectedFee])
//  ↑ 依赖了对象，但没有包含 getQuote 函数
```

### 问题分析

1. **`getQuote` 函数每次渲染都重新创建**

   - 没有使用 `useCallback` 包裹
   - 每次渲染都是新的函数引用

2. **`useEffect` 的依赖问题**

   - 依赖了 `tokenIn`, `tokenOut`, `selectedFee` 对象
   - 这些对象引用可能不稳定
   - 没有包含 `getQuote` 函数（闭包陷阱）
   - 可能调用的是旧的 `getQuote` 函数

3. **`swapRouter` 依赖问题**
   - `getQuote` 内部使用了 `swapRouter`
   - 但 `swapRouter` 可能在渲染时还未准备好
   - 没有正确处理异步加载

## 🔧 修复方案

### 1. 使用 `useCallback` 稳定 `getQuote` 函数

```typescript
// ✅ 修复后
const getQuote = useCallback(
  async (amount: string) => {
    if (!amount || parseFloat(amount) <= 0) {
      setAmountOut("")
      return
    }

    const router = swapRouterRef.current
    if (!router) {
      console.log("⏳ Swap router not ready")
      return
    }

    setQuoteLoading(true)
    try {
      const amountInWei = parseUnits(amount, 18)

      const quote = await router.quoteExactInput({
        tokenIn: tokenIn.address,
        tokenOut: tokenOut.address,
        indexPath: [selectedFee.index],
        amountIn: amountInWei,
        sqrtPriceLimitX96: 0
      })

      setAmountOut(formatUnits(quote, 18))
    } catch (error) {
      console.error("❌ Error getting quote:", error)
      setAmountOut("")
    } finally {
      setQuoteLoading(false)
    }
  },
  [tokenIn.address, tokenIn.symbol, tokenOut.address, tokenOut.symbol, selectedFee.index, selectedFee.label]
)
// ✅ 只依赖基本类型（string, number）
```

**关键点**:

- 使用 `useCallback` 包裹，只在依赖变化时重新创建
- 只依赖基本类型：`tokenIn.address`, `tokenOut.address`, `selectedFee.index` 等
- 不依赖对象引用

### 2. 使用 `useRef` 保存 `swapRouter`

```typescript
// 使用 useRef 保存 swapRouter，避免依赖问题
const swapRouterRef = useRef(swapRouter)
swapRouterRef.current = swapRouter

const getQuote = useCallback(
  async (amount: string) => {
    // 从 ref 中获取最新的 router
    const router = swapRouterRef.current
    if (!router) {
      return
    }
    // ... 使用 router
  },
  [tokenIn.address, tokenOut.address, selectedFee.index]
)
// ✅ 不需要依赖 swapRouter
```

**关键点**:

- `swapRouter` 通过 `useRef` 访问，不作为依赖
- 避免因 `swapRouter` 引用变化导致 `getQuote` 重新创建

### 3. 修复 `useEffect` 依赖

```typescript
// ✅ 修复后的 useEffect
useEffect(() => {
  const timer = setTimeout(() => {
    if (amountIn) {
      console.log("🔄 Input changed, getting quote for:", amountIn)
      getQuote(amountIn)
    } else {
      setAmountOut("")
    }
  }, 500) // 防抖 500ms

  return () => clearTimeout(timer)
}, [amountIn, getQuote])
// ✅ 只依赖 amountIn 和稳定的 getQuote 函数
```

**关键点**:

- 只依赖 `[amountIn, getQuote]`
- `getQuote` 现在是稳定的（通过 `useCallback`）
- 不再依赖对象 `tokenIn`, `tokenOut`, `selectedFee`
- 这些变化已经在 `getQuote` 的依赖中处理了

## 📊 修复前后对比

### 修复前

```
用户输入 "100"
→ amountIn 改变
→ useEffect 触发
→ 调用 getQuote(amountIn)
→ 但 getQuote 可能是旧的函数（闭包问题）
→ 或者 swapRouter 还未准备好
→ ❌ 没有输出 TokenB 的数量
```

### 修复后

```
用户输入 "100"
→ amountIn 改变
→ useEffect 触发（500ms 防抖）
→ 调用最新的 getQuote(amountIn)
→ getQuote 从 ref 获取最新的 swapRouter
→ 调用合约的 quoteExactInput
→ ✅ 成功获取报价并显示 TokenB 的数量

控制台日志：
🔄 Input changed, getting quote for: 100
💰 Getting quote... { tokenIn: "MNA", tokenOut: "MNB", ... }
✅ Quote received: 95.5
```

## 🎯 工作流程

### 完整的自动报价流程

```
1. 用户在输入框输入数量
   ↓
2. amountIn 状态改变
   ↓
3. useEffect 检测到 amountIn 变化
   ↓
4. 启动 500ms 防抖计时器
   ↓
5. 计时器结束后调用 getQuote(amountIn)
   ↓
6. getQuote 函数执行：
   a. 检查 amountIn 是否有效
   b. 从 swapRouterRef 获取最新的 router
   c. 转换金额为 Wei 单位
   d. 调用 router.quoteExactInput()
   e. 获取报价并格式化
   ↓
7. setAmountOut(报价结果)
   ↓
8. ✅ 页面显示 TokenB 的数量
```

### 触发自动报价的场景

1. **用户输入金额**

   - 输入框值改变 → `amountIn` 变化 → 触发报价

2. **切换代币**

   - 选择不同的 TokenIn/TokenOut → `getQuote` 重新创建 → 触发报价

3. **切换费率**

   - 选择不同的费率 → `getQuote` 重新创建 → 触发报价

4. **点击 MAX 按钮**
   - 设置最大金额 → `amountIn` 变化 → 触发报价

## 🔍 调试日志

### 正常情况

打开控制台（F12），输入金额后应该看到：

```
🔄 Input changed, getting quote for: 100
💰 Getting quote... {
  tokenIn: "MNA",
  tokenOut: "MNB",
  amountIn: "100",
  fee: "0.30%"
}
✅ Quote received: 95.5
```

### 异常情况

#### 1. Router 未准备好

```
🔄 Input changed, getting quote for: 100
⏳ Swap router not ready
```

**解决**: 等待几秒钟，或刷新页面

#### 2. 合约调用失败

```
🔄 Input changed, getting quote for: 100
💰 Getting quote...
❌ Error getting quote: Error: execution reverted
```

**可能原因**:

- 流动性池不存在
- 该费率层级没有流动性
- 网络问题

## ✅ 测试清单

- [ ] 输入金额后，等待 500ms，自动显示输出金额
- [ ] 切换 TokenIn，自动重新计算报价
- [ ] 切换 TokenOut，自动重新计算报价
- [ ] 切换费率，自动重新计算报价
- [ ] 点击 MAX 按钮，自动计算报价
- [ ] 清空输入，输出金额也清空
- [ ] 控制台有清晰的日志
- [ ] 防抖功能正常（快速输入不会触发多次）

## 💡 技术要点

### 1. React Hooks 防抖模式

```typescript
useEffect(() => {
  const timer = setTimeout(() => {
    // 执行操作
  }, 500)

  return () => clearTimeout(timer) // 清理定时器
}, [dependency])
```

### 2. useCallback 与 useRef 组合

```typescript
// 保存对象引用
const objectRef = useRef(object)
objectRef.current = object

// 稳定的回调函数
const callback = useCallback(() => {
  const obj = objectRef.current // 访问最新值
  // ... 使用 obj
}, [id, name]) // 只依赖基本类型
```

### 3. 异步状态管理

```typescript
const [loading, setLoading] = useState(false)

const fetchData = async () => {
  setLoading(true)
  try {
    const data = await api.fetch()
    setData(data)
  } catch (error) {
    console.error(error)
  } finally {
    setLoading(false) // 确保总是重置 loading
  }
}
```

## 📝 相关文件

- `web/src/components/Swap.tsx` - 主要修改文件
- `web/src/hooks/useContract.ts` - `useSwapRouter` Hook
- `web/src/config/abis.ts` - SwapRouter ABI（包含 `quoteExactInput` 方法）

---

**修复完成**: 2025-10-23  
**问题类型**: React Hooks 闭包问题 + 依赖管理  
**修复难度**: ⭐⭐⭐ (中等)  
**用户体验提升**: ⭐⭐⭐⭐⭐ (非常高)
