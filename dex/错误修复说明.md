# 错误修复说明

## 🐛 问题描述

在查询代币余额时出现以下错误：

```
Error: could not coalesce error (error={ "payload": { "method": "eth_requestAccounts", "params": [] } }, payload={ "method": "eth_requestAccounts", "params": [] }, code=UNKNOWN_ERROR, version=6.15.0)
```

## 🔍 问题分析

### 根本原因

**核心问题**: `useEthersSigner()` hook 的实现有误

1. **错误的实现方式**:

```typescript
// ❌ 错误：在 useMemo 中返回 async 函数
export function useEthersSigner() {
  const { data: walletClient } = useWalletClient()
  const provider = useEthersProvider()

  return useMemo(async () => {
    // ❌ 返回 Promise
    if (!walletClient || !provider) return null
    return await provider.getSigner(walletClient.account.address)
  }, [walletClient, provider])
}
```

2. **导致的问题**:
   - Hook 返回的是 **Promise 对象** 而不是实际的 **signer**
   - 所有使用这个 hook 的地方都需要 `await`，但这在 React 组件中很难正确处理
   - 在 `useTokenBalance` 中尝试获取 signer 时触发了错误

## ✅ 解决方案

### 1. 修复 useEthersSigner Hook

使用 `useState` 和 `useEffect` 替代 `useMemo`：

```typescript
// ✅ 正确：使用 useState + useEffect 处理异步
export function useEthersSigner() {
  const { data: walletClient } = useWalletClient()
  const provider = useEthersProvider()
  const [signer, setSigner] = useState<any>(null)

  useEffect(() => {
    if (!walletClient || !provider) {
      setSigner(null)
      return
    }

    const getSigner = async () => {
      try {
        const s = await provider.getSigner(walletClient.account.address)
        setSigner(s)
      } catch (error) {
        console.error("Error getting signer:", error)
        setSigner(null)
      }
    }

    getSigner()
  }, [walletClient, provider])

  return signer // 直接返回 signer，不是 Promise
}
```

### 2. 更新所有合约 Hooks

移除 `async/await`，直接使用 signer：

```typescript
// ❌ 之前
export function useSwapRouter() {
  const provider = useEthersProvider()
  const signerPromise = useEthersSigner() // Promise
  const { isConnected } = useAccount()

  return useMemo(async () => {
    // async 导致返回 Promise
    if (isConnected) {
      const signer = await signerPromise // await Promise
      if (signer) {
        return new Contract(CONTRACTS.SwapRouter, SWAP_ROUTER_ABI, signer)
      }
    }
    if (provider) {
      return new Contract(CONTRACTS.SwapRouter, SWAP_ROUTER_ABI, provider)
    }
    return null
  }, [provider, signerPromise, isConnected])
}

// ✅ 修复后
export function useSwapRouter() {
  const provider = useEthersProvider()
  const signer = useEthersSigner() // 直接获取 signer
  const { isConnected } = useAccount()

  return useMemo(() => {
    // 同步函数
    if (isConnected && signer) {
      return new Contract(CONTRACTS.SwapRouter, SWAP_ROUTER_ABI, signer)
    }
    if (provider) {
      return new Contract(CONTRACTS.SwapRouter, SWAP_ROUTER_ABI, provider)
    }
    return null
  }, [provider, signer, isConnected])
}
```

### 3. 更新 useTokenBalance Hook

移除 Promise 处理：

```typescript
// ❌ 之前
const tokenContractPromise = useTokenContract(tokenAddress)

const fetchBalance = async () => {
  const tokenContract = await tokenContractPromise // await Promise
  if (!tokenContract) return
  const bal = await tokenContract.balanceOf(address)
  setBalance(formatUnits(bal, 18))
}

// ✅ 修复后
const tokenContract = useTokenContract(tokenAddress) // 直接获取 contract

const fetchBalance = async () => {
  if (!tokenContract) return // 直接检查
  const bal = await tokenContract.balanceOf(address)
  setBalance(formatUnits(bal, 18))
}
```

### 4. 更新所有组件

移除 `await` 和 `Promise` 处理：

```typescript
// ❌ Swap.tsx 之前
const swapRouterPromise = useSwapRouter()
const swapRouter = await swapRouterPromise

// ✅ Swap.tsx 修复后
const swapRouter = useSwapRouter()

// ❌ Liquidity.tsx 之前
const positionManagerPromise = usePositionManager()
const positionManager = await positionManagerPromise

// ✅ Liquidity.tsx 修复后
const positionManager = usePositionManager()

// ❌ Positions.tsx 之前
const positionManagerPromise = usePositionManager()
const positionManager = await positionManagerPromise

// ✅ Positions.tsx 修复后
const positionManager = usePositionManager()
```

## 📋 修改文件列表

### 核心修复

1. ✅ `web/src/hooks/useContract.ts` - 修复所有合约 hooks
2. ✅ `web/src/hooks/useTokenBalance.ts` - 移除 Promise 处理

### 组件更新

3. ✅ `web/src/components/Swap.tsx` - 更新合约使用方式
4. ✅ `web/src/components/Liquidity.tsx` - 更新合约使用方式
5. ✅ `web/src/components/Positions.tsx` - 更新合约使用方式

## 🎯 修复效果

### Before (错误)

```typescript
// 返回 Promise，需要 await
const contractPromise = useContract()
const contract = await contractPromise // ❌ 在组件中很难处理
```

### After (正确)

```typescript
// 直接返回 contract 或 null
const contract = useContract()
if (contract) {
  // 可以直接使用
  const result = await contract.someMethod()
}
```

## ✨ 改进点

1. **更好的错误处理**

   - 在 `useEthersSigner` 中添加 try-catch
   - 所有合约操作前都检查 contract 是否存在

2. **更清晰的代码**

   - 移除了复杂的 async/await 链
   - Hook 返回值类型更明确

3. **更好的性能**
   - 使用 `useState` 缓存 signer
   - 避免不必要的重新创建 contract 实例

## 🔍 测试验证

修复后应该能够：

1. ✅ 正常连接钱包
2. ✅ 显示 ETH 余额
3. ✅ 显示代币余额
4. ✅ 执行交换操作
5. ✅ 添加流动性
6. ✅ 查看持仓

## 📚 React Hooks 最佳实践

### ❌ 错误模式

```typescript
// 不要在 useMemo 中返回 Promise
const value = useMemo(async () => {
  return await someAsyncOperation()
}, [deps])
```

### ✅ 正确模式

```typescript
// 使用 useState + useEffect 处理异步
const [value, setValue] = useState(null)

useEffect(() => {
  const fetchData = async () => {
    const result = await someAsyncOperation()
    setValue(result)
  }
  fetchData()
}, [deps])
```

## 🎉 总结

通过将异步操作从 `useMemo` 移到 `useEffect` + `useState`，我们：

- ✅ 修复了余额查询错误
- ✅ 简化了代码结构
- ✅ 提高了代码可维护性
- ✅ 符合 React Hooks 最佳实践

---

## 🐛 第二个问题：添加流动性报错

### 问题描述

```
Error: contract runner does not support sending transactions
(operation="sendTransaction", code=UNSUPPORTED_OPERATION, version=6.15.0)
```

### 根本原因

在合约 hooks 中使用了错误的逻辑判断：

```typescript
// ❌ 错误：先检查 isConnected，但此时 signer 可能还没准备好
if (isConnected && signer) {
  return new Contract(address, abi, signer)
}
if (provider) {
  return new Contract(address, abi, provider) // 使用了只读的 provider
}
```

问题流程：

1. 用户连接钱包，`isConnected` 变为 `true`
2. 但 `signer` 可能还在异步获取中（`useEffect` 执行需要时间）
3. 第一个 `if` 条件不满足（signer 为 null）
4. 执行第二个 `if`，使用 `provider` 创建合约
5. **Provider 只能读取数据，不能发送交易**
6. 调用 `mint()` 时报错 `UNSUPPORTED_OPERATION`

### 解决方案

优先使用 `signer`，移除 `isConnected` 检查：

```typescript
// ✅ 正确：优先检查 signer，确保能发送交易
export function usePositionManager() {
  const provider = useEthersProvider()
  const signer = useEthersSigner()

  return useMemo(() => {
    // 优先使用 signer（可以发送交易）
    if (signer) {
      return new Contract(CONTRACTS.PositionManager, POSITION_MANAGER_ABI, signer)
    }
    // 降级使用 provider（只读）
    if (provider) {
      return new Contract(CONTRACTS.PositionManager, POSITION_MANAGER_ABI, provider)
    }
    return null
  }, [provider, signer])
}
```

### 改进的错误处理

在组件中添加更友好的错误提示：

```typescript
// 添加流动性
const addLiquidity = async () => {
  // 检查钱包连接
  if (!isConnected) {
    alert("Please connect wallet first")
    return
  }

  // 检查合约是否准备好
  if (!positionManager) {
    alert("Position manager not found. Please wait a moment and try again.")
    return
  }

  try {
    // ... 执行交易
  } catch (error: any) {
    // 友好的错误提示
    let errorMessage = error.message
    if (error.message.includes("UNSUPPORTED_OPERATION")) {
      errorMessage = "Please make sure your wallet is connected and unlocked."
    } else if (error.message.includes("user rejected")) {
      errorMessage = "Transaction was rejected."
    }
    alert(`Add liquidity failed: ${errorMessage}`)
  }
}
```

### 修复清单

1. ✅ `useSwapRouter()` - 优先使用 signer
2. ✅ `usePositionManager()` - 优先使用 signer
3. ✅ `usePoolManager()` - 优先使用 signer
4. ✅ `useTokenContract()` - 优先使用 signer
5. ✅ Swap.tsx - 添加连接检查和错误提示
6. ✅ Liquidity.tsx - 添加连接检查和错误提示

### 最终效果

现在所有功能都可以正常工作：

- ✅ 查看余额（使用 provider 或 signer）
- ✅ 授权代币（需要 signer）
- ✅ 交换代币（需要 signer）
- ✅ 添加流动性（需要 signer）
- ✅ 移除流动性（需要 signer）
- ✅ 提取手续费（需要 signer）

所有问题都已修复！🎉
