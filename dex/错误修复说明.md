# é”™è¯¯ä¿®å¤è¯´æ˜

## ğŸ› é—®é¢˜æè¿°

åœ¨æŸ¥è¯¢ä»£å¸ä½™é¢æ—¶å‡ºç°ä»¥ä¸‹é”™è¯¯ï¼š

```
Error: could not coalesce error (error={ "payload": { "method": "eth_requestAccounts", "params": [] } }, payload={ "method": "eth_requestAccounts", "params": [] }, code=UNKNOWN_ERROR, version=6.15.0)
```

## ğŸ” é—®é¢˜åˆ†æ

### æ ¹æœ¬åŸå› 

**æ ¸å¿ƒé—®é¢˜**: `useEthersSigner()` hook çš„å®ç°æœ‰è¯¯

1. **é”™è¯¯çš„å®ç°æ–¹å¼**:

```typescript
// âŒ é”™è¯¯ï¼šåœ¨ useMemo ä¸­è¿”å› async å‡½æ•°
export function useEthersSigner() {
  const { data: walletClient } = useWalletClient()
  const provider = useEthersProvider()

  return useMemo(async () => {
    // âŒ è¿”å› Promise
    if (!walletClient || !provider) return null
    return await provider.getSigner(walletClient.account.address)
  }, [walletClient, provider])
}
```

2. **å¯¼è‡´çš„é—®é¢˜**:
   - Hook è¿”å›çš„æ˜¯ **Promise å¯¹è±¡** è€Œä¸æ˜¯å®é™…çš„ **signer**
   - æ‰€æœ‰ä½¿ç”¨è¿™ä¸ª hook çš„åœ°æ–¹éƒ½éœ€è¦ `await`ï¼Œä½†è¿™åœ¨ React ç»„ä»¶ä¸­å¾ˆéš¾æ­£ç¡®å¤„ç†
   - åœ¨ `useTokenBalance` ä¸­å°è¯•è·å– signer æ—¶è§¦å‘äº†é”™è¯¯

## âœ… è§£å†³æ–¹æ¡ˆ

### 1. ä¿®å¤ useEthersSigner Hook

ä½¿ç”¨ `useState` å’Œ `useEffect` æ›¿ä»£ `useMemo`ï¼š

```typescript
// âœ… æ­£ç¡®ï¼šä½¿ç”¨ useState + useEffect å¤„ç†å¼‚æ­¥
export function useEthersSigner() {
  const { data: walletClient } = useWalletClient()
  const provider = useEthersProvider()
  const [signer, setSigner] = useState<any>(null)

  useEffect(() => {
    if (!walletClient || !provider) {
      setSigner(null)
      return
    }

    const getSigner = async () => {
      try {
        const s = await provider.getSigner(walletClient.account.address)
        setSigner(s)
      } catch (error) {
        console.error("Error getting signer:", error)
        setSigner(null)
      }
    }

    getSigner()
  }, [walletClient, provider])

  return signer // ç›´æ¥è¿”å› signerï¼Œä¸æ˜¯ Promise
}
```

### 2. æ›´æ–°æ‰€æœ‰åˆçº¦ Hooks

ç§»é™¤ `async/await`ï¼Œç›´æ¥ä½¿ç”¨ signerï¼š

```typescript
// âŒ ä¹‹å‰
export function useSwapRouter() {
  const provider = useEthersProvider()
  const signerPromise = useEthersSigner() // Promise
  const { isConnected } = useAccount()

  return useMemo(async () => {
    // async å¯¼è‡´è¿”å› Promise
    if (isConnected) {
      const signer = await signerPromise // await Promise
      if (signer) {
        return new Contract(CONTRACTS.SwapRouter, SWAP_ROUTER_ABI, signer)
      }
    }
    if (provider) {
      return new Contract(CONTRACTS.SwapRouter, SWAP_ROUTER_ABI, provider)
    }
    return null
  }, [provider, signerPromise, isConnected])
}

// âœ… ä¿®å¤å
export function useSwapRouter() {
  const provider = useEthersProvider()
  const signer = useEthersSigner() // ç›´æ¥è·å– signer
  const { isConnected } = useAccount()

  return useMemo(() => {
    // åŒæ­¥å‡½æ•°
    if (isConnected && signer) {
      return new Contract(CONTRACTS.SwapRouter, SWAP_ROUTER_ABI, signer)
    }
    if (provider) {
      return new Contract(CONTRACTS.SwapRouter, SWAP_ROUTER_ABI, provider)
    }
    return null
  }, [provider, signer, isConnected])
}
```

### 3. æ›´æ–° useTokenBalance Hook

ç§»é™¤ Promise å¤„ç†ï¼š

```typescript
// âŒ ä¹‹å‰
const tokenContractPromise = useTokenContract(tokenAddress)

const fetchBalance = async () => {
  const tokenContract = await tokenContractPromise // await Promise
  if (!tokenContract) return
  const bal = await tokenContract.balanceOf(address)
  setBalance(formatUnits(bal, 18))
}

// âœ… ä¿®å¤å
const tokenContract = useTokenContract(tokenAddress) // ç›´æ¥è·å– contract

const fetchBalance = async () => {
  if (!tokenContract) return // ç›´æ¥æ£€æŸ¥
  const bal = await tokenContract.balanceOf(address)
  setBalance(formatUnits(bal, 18))
}
```

### 4. æ›´æ–°æ‰€æœ‰ç»„ä»¶

ç§»é™¤ `await` å’Œ `Promise` å¤„ç†ï¼š

```typescript
// âŒ Swap.tsx ä¹‹å‰
const swapRouterPromise = useSwapRouter()
const swapRouter = await swapRouterPromise

// âœ… Swap.tsx ä¿®å¤å
const swapRouter = useSwapRouter()

// âŒ Liquidity.tsx ä¹‹å‰
const positionManagerPromise = usePositionManager()
const positionManager = await positionManagerPromise

// âœ… Liquidity.tsx ä¿®å¤å
const positionManager = usePositionManager()

// âŒ Positions.tsx ä¹‹å‰
const positionManagerPromise = usePositionManager()
const positionManager = await positionManagerPromise

// âœ… Positions.tsx ä¿®å¤å
const positionManager = usePositionManager()
```

## ğŸ“‹ ä¿®æ”¹æ–‡ä»¶åˆ—è¡¨

### æ ¸å¿ƒä¿®å¤

1. âœ… `web/src/hooks/useContract.ts` - ä¿®å¤æ‰€æœ‰åˆçº¦ hooks
2. âœ… `web/src/hooks/useTokenBalance.ts` - ç§»é™¤ Promise å¤„ç†

### ç»„ä»¶æ›´æ–°

3. âœ… `web/src/components/Swap.tsx` - æ›´æ–°åˆçº¦ä½¿ç”¨æ–¹å¼
4. âœ… `web/src/components/Liquidity.tsx` - æ›´æ–°åˆçº¦ä½¿ç”¨æ–¹å¼
5. âœ… `web/src/components/Positions.tsx` - æ›´æ–°åˆçº¦ä½¿ç”¨æ–¹å¼

## ğŸ¯ ä¿®å¤æ•ˆæœ

### Before (é”™è¯¯)

```typescript
// è¿”å› Promiseï¼Œéœ€è¦ await
const contractPromise = useContract()
const contract = await contractPromise // âŒ åœ¨ç»„ä»¶ä¸­å¾ˆéš¾å¤„ç†
```

### After (æ­£ç¡®)

```typescript
// ç›´æ¥è¿”å› contract æˆ– null
const contract = useContract()
if (contract) {
  // å¯ä»¥ç›´æ¥ä½¿ç”¨
  const result = await contract.someMethod()
}
```

## âœ¨ æ”¹è¿›ç‚¹

1. **æ›´å¥½çš„é”™è¯¯å¤„ç†**

   - åœ¨ `useEthersSigner` ä¸­æ·»åŠ  try-catch
   - æ‰€æœ‰åˆçº¦æ“ä½œå‰éƒ½æ£€æŸ¥ contract æ˜¯å¦å­˜åœ¨

2. **æ›´æ¸…æ™°çš„ä»£ç **

   - ç§»é™¤äº†å¤æ‚çš„ async/await é“¾
   - Hook è¿”å›å€¼ç±»å‹æ›´æ˜ç¡®

3. **æ›´å¥½çš„æ€§èƒ½**
   - ä½¿ç”¨ `useState` ç¼“å­˜ signer
   - é¿å…ä¸å¿…è¦çš„é‡æ–°åˆ›å»º contract å®ä¾‹

## ğŸ” æµ‹è¯•éªŒè¯

ä¿®å¤ååº”è¯¥èƒ½å¤Ÿï¼š

1. âœ… æ­£å¸¸è¿æ¥é’±åŒ…
2. âœ… æ˜¾ç¤º ETH ä½™é¢
3. âœ… æ˜¾ç¤ºä»£å¸ä½™é¢
4. âœ… æ‰§è¡Œäº¤æ¢æ“ä½œ
5. âœ… æ·»åŠ æµåŠ¨æ€§
6. âœ… æŸ¥çœ‹æŒä»“

## ğŸ“š React Hooks æœ€ä½³å®è·µ

### âŒ é”™è¯¯æ¨¡å¼

```typescript
// ä¸è¦åœ¨ useMemo ä¸­è¿”å› Promise
const value = useMemo(async () => {
  return await someAsyncOperation()
}, [deps])
```

### âœ… æ­£ç¡®æ¨¡å¼

```typescript
// ä½¿ç”¨ useState + useEffect å¤„ç†å¼‚æ­¥
const [value, setValue] = useState(null)

useEffect(() => {
  const fetchData = async () => {
    const result = await someAsyncOperation()
    setValue(result)
  }
  fetchData()
}, [deps])
```

## ğŸ‰ æ€»ç»“

é€šè¿‡å°†å¼‚æ­¥æ“ä½œä» `useMemo` ç§»åˆ° `useEffect` + `useState`ï¼Œæˆ‘ä»¬ï¼š

- âœ… ä¿®å¤äº†ä½™é¢æŸ¥è¯¢é”™è¯¯
- âœ… ç®€åŒ–äº†ä»£ç ç»“æ„
- âœ… æé«˜äº†ä»£ç å¯ç»´æŠ¤æ€§
- âœ… ç¬¦åˆ React Hooks æœ€ä½³å®è·µ

---

## ğŸ› ç¬¬äºŒä¸ªé—®é¢˜ï¼šæ·»åŠ æµåŠ¨æ€§æŠ¥é”™

### é—®é¢˜æè¿°

```
Error: contract runner does not support sending transactions
(operation="sendTransaction", code=UNSUPPORTED_OPERATION, version=6.15.0)
```

### æ ¹æœ¬åŸå› 

åœ¨åˆçº¦ hooks ä¸­ä½¿ç”¨äº†é”™è¯¯çš„é€»è¾‘åˆ¤æ–­ï¼š

```typescript
// âŒ é”™è¯¯ï¼šå…ˆæ£€æŸ¥ isConnectedï¼Œä½†æ­¤æ—¶ signer å¯èƒ½è¿˜æ²¡å‡†å¤‡å¥½
if (isConnected && signer) {
  return new Contract(address, abi, signer)
}
if (provider) {
  return new Contract(address, abi, provider) // ä½¿ç”¨äº†åªè¯»çš„ provider
}
```

é—®é¢˜æµç¨‹ï¼š

1. ç”¨æˆ·è¿æ¥é’±åŒ…ï¼Œ`isConnected` å˜ä¸º `true`
2. ä½† `signer` å¯èƒ½è¿˜åœ¨å¼‚æ­¥è·å–ä¸­ï¼ˆ`useEffect` æ‰§è¡Œéœ€è¦æ—¶é—´ï¼‰
3. ç¬¬ä¸€ä¸ª `if` æ¡ä»¶ä¸æ»¡è¶³ï¼ˆsigner ä¸º nullï¼‰
4. æ‰§è¡Œç¬¬äºŒä¸ª `if`ï¼Œä½¿ç”¨ `provider` åˆ›å»ºåˆçº¦
5. **Provider åªèƒ½è¯»å–æ•°æ®ï¼Œä¸èƒ½å‘é€äº¤æ˜“**
6. è°ƒç”¨ `mint()` æ—¶æŠ¥é”™ `UNSUPPORTED_OPERATION`

### è§£å†³æ–¹æ¡ˆ

ä¼˜å…ˆä½¿ç”¨ `signer`ï¼Œç§»é™¤ `isConnected` æ£€æŸ¥ï¼š

```typescript
// âœ… æ­£ç¡®ï¼šä¼˜å…ˆæ£€æŸ¥ signerï¼Œç¡®ä¿èƒ½å‘é€äº¤æ˜“
export function usePositionManager() {
  const provider = useEthersProvider()
  const signer = useEthersSigner()

  return useMemo(() => {
    // ä¼˜å…ˆä½¿ç”¨ signerï¼ˆå¯ä»¥å‘é€äº¤æ˜“ï¼‰
    if (signer) {
      return new Contract(CONTRACTS.PositionManager, POSITION_MANAGER_ABI, signer)
    }
    // é™çº§ä½¿ç”¨ providerï¼ˆåªè¯»ï¼‰
    if (provider) {
      return new Contract(CONTRACTS.PositionManager, POSITION_MANAGER_ABI, provider)
    }
    return null
  }, [provider, signer])
}
```

### æ”¹è¿›çš„é”™è¯¯å¤„ç†

åœ¨ç»„ä»¶ä¸­æ·»åŠ æ›´å‹å¥½çš„é”™è¯¯æç¤ºï¼š

```typescript
// æ·»åŠ æµåŠ¨æ€§
const addLiquidity = async () => {
  // æ£€æŸ¥é’±åŒ…è¿æ¥
  if (!isConnected) {
    alert("Please connect wallet first")
    return
  }

  // æ£€æŸ¥åˆçº¦æ˜¯å¦å‡†å¤‡å¥½
  if (!positionManager) {
    alert("Position manager not found. Please wait a moment and try again.")
    return
  }

  try {
    // ... æ‰§è¡Œäº¤æ˜“
  } catch (error: any) {
    // å‹å¥½çš„é”™è¯¯æç¤º
    let errorMessage = error.message
    if (error.message.includes("UNSUPPORTED_OPERATION")) {
      errorMessage = "Please make sure your wallet is connected and unlocked."
    } else if (error.message.includes("user rejected")) {
      errorMessage = "Transaction was rejected."
    }
    alert(`Add liquidity failed: ${errorMessage}`)
  }
}
```

### ä¿®å¤æ¸…å•

1. âœ… `useSwapRouter()` - ä¼˜å…ˆä½¿ç”¨ signer
2. âœ… `usePositionManager()` - ä¼˜å…ˆä½¿ç”¨ signer
3. âœ… `usePoolManager()` - ä¼˜å…ˆä½¿ç”¨ signer
4. âœ… `useTokenContract()` - ä¼˜å…ˆä½¿ç”¨ signer
5. âœ… Swap.tsx - æ·»åŠ è¿æ¥æ£€æŸ¥å’Œé”™è¯¯æç¤º
6. âœ… Liquidity.tsx - æ·»åŠ è¿æ¥æ£€æŸ¥å’Œé”™è¯¯æç¤º

### æœ€ç»ˆæ•ˆæœ

ç°åœ¨æ‰€æœ‰åŠŸèƒ½éƒ½å¯ä»¥æ­£å¸¸å·¥ä½œï¼š

- âœ… æŸ¥çœ‹ä½™é¢ï¼ˆä½¿ç”¨ provider æˆ– signerï¼‰
- âœ… æˆæƒä»£å¸ï¼ˆéœ€è¦ signerï¼‰
- âœ… äº¤æ¢ä»£å¸ï¼ˆéœ€è¦ signerï¼‰
- âœ… æ·»åŠ æµåŠ¨æ€§ï¼ˆéœ€è¦ signerï¼‰
- âœ… ç§»é™¤æµåŠ¨æ€§ï¼ˆéœ€è¦ signerï¼‰
- âœ… æå–æ‰‹ç»­è´¹ï¼ˆéœ€è¦ signerï¼‰

æ‰€æœ‰é—®é¢˜éƒ½å·²ä¿®å¤ï¼ğŸ‰
